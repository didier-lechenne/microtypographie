/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Microtypographie
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  openDoubleQuote: "\xAB\u202F",
  // Guillemet français ouvrant avec espace fine insécable
  closeDoubleQuote: "\u202F\xBB",
  // Guillemet français fermant avec espace fine insécable
  openSingleQuote: "\u201C",
  // Apostrophe typographique
  closeSingleQuote: "\u201D",
  // Apostrophe typographique
  frenchRulesEnabled: true,
  dashesEnabled: true,
  skipEnDash: false,
  ellipsisEnabled: true,
  guillemetsEnabled: false,
  highlightEnabled: false,
  highlightButton: true,
  tabTitleBarButton: true
  // Activé par défaut
};

// src/settings/settingsTab.ts
var import_obsidian = require("obsidian");
var MicrotypographieSettingTab = class extends import_obsidian.PluginSettingTab {
  // Pour stocker la référence au container du champ de texte
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Microtypographie" });
    this.createBasicSettings(containerEl);
    this.createHighlightSettings(containerEl);
  }
  /**
   * Crée le bloc d'information
   * @param containerEl Conteneur parent
   */
  createInfoBlock(containerEl) {
    const infoContainer = containerEl.createEl("div", {
      cls: "microtypographie-info-container"
    });
    const infoContent = infoContainer.createEl("div", {
      cls: "microtypographie-info-content"
    });
    infoContent.createEl("p", {
      text: "Ce plugin applique automatiquement une partie des r\xE8gles typographiques fran\xE7aises pendant la saisie."
    });
    const rulesList = infoContent.createEl("ul");
    rulesList.createEl("li", {
      text: "Espaces ins\xE9cables avant les ponctuations doubles (! ? ; \xBB)"
    });
    rulesList.createEl("li", { text: "Espaces fines ins\xE9cables avant (:)" });
    rulesList.createEl("li", {
      text: "Espaces fines ins\xE9cables dans les guillemets fran\xE7ais (\xAB\u202Fphrase\u202F\xBB)"
    });
    rulesList.createEl("li", { text: "Apostrophe typographique (\u2019)" });
    rulesList.createEl("li", {
      text: "Conversion de (--) en tiret cadratin (\u2014)"
    });
    infoContent.createEl("p", {
      text: "Utilisez Alt+F pour appliquer toutes les r\xE8gles sur un texte existant."
    });
    const transformationsList = infoContent.createEl("ul");
    transformationsList.createEl("li", {
      text: 'Conversion de (" ") en guillemets fran\xE7ais (\xAB \xBB)'
    });
    transformationsList.createEl("li", {
      text: "Conversion de ' en apostrophe typographique (\u2019)"
    });
    transformationsList.createEl("li", {
      text: "Espace fine ins\xE9cable avant : (! ? ; \xBB \u203A)"
    });
    transformationsList.createEl("li", {
      text: "Espace ins\xE9cable avant : (:)"
    });
    transformationsList.createEl("li", {
      text: "Espace fine ins\xE9cable apr\xE8s : (\xAB \u2039)"
    });
    transformationsList.createEl("li", {
      text: "Espace ins\xE9cable apr\xE8s les mots d'une lettre (a, y, \xE0 \u2026)"
    });
    transformationsList.createEl("li", {
      text: "Espace ins\xE9cable dans les noms compos\xE9s (Jean\xA0Dupont)"
    });
    transformationsList.createEl("li", {
      text: "Espace ins\xE9cable avant les initiales (M.\xA0Dupont)"
    });
    transformationsList.createEl("li", {
      text: "Espace ins\xE9cable avant (si\xE8cle) (XXe\xA0si\xE8cle)"
    });
    transformationsList.createEl("li", {
      text: "Conversion de (oe/OE) en ligatures (\u0153/\u0152)"
    });
    transformationsList.createEl("li", {
      text: "Conversion de (--) en tiret cadratin (\u2014)"
    });
    transformationsList.createEl("li", {
      text: "Conversion de (...) en points de suspension (\u2026)"
    });
    infoContent.createEl("p", {
      text: "Info pour ins\xE9rer une espace ins\xE9cable avec Obsidian :"
    });
    const shortcutsList = infoContent.createEl("ul");
    shortcutsList.createEl("li", { text: "Windows : Alt+255" });
    shortcutsList.createEl("li", { text: "macOS : Alt+Espace" });
    this.addInfoBlockStyles();
  }
  /**
   * Ajoute les styles CSS pour le bloc d'information
   */
  addInfoBlockStyles() {
    const styleElement = document.createElement("style");
    styleElement.textContent = `
        .microtypographie-info-container {
            background-color: rgba(var(--interactive-accent-rgb), 0.1);
            border-left: 4px solid var(--interactive-accent);
            margin: 1em 0;
            padding: 1em;
            border-radius: 4px;
        }
        
        .microtypographie-info-container h2 {
            margin-top: 0;
            font-size: 1.2em;
            color: var(--interactive-accent);
        }
        
        .microtypographie-info-content p {
            margin: 0.5em 0;
        }
    `;
    document.head.appendChild(styleElement);
  }
  /**
   * Crée les paramètres de base
   * @param containerEl Conteneur parent
   */
  createBasicSettings(containerEl) {
    const desEl = containerEl.createEl("p", {
      text: "Caract\xE8res typographiques personnalisables"
    });
    desEl.style.fontWeight = "bold";
    new import_obsidian.Setting(containerEl).setName("Guillemet double ouvrant").addText(
      (text) => text.setValue(this.plugin.settings.openDoubleQuote).onChange(async (value) => {
        this.plugin.settings.openDoubleQuote = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Guillemet double fermant").addText(
      (text) => text.setValue(this.plugin.settings.closeDoubleQuote).onChange(async (value) => {
        this.plugin.settings.closeDoubleQuote = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Guillemet simple ouvrant").addText(
      (text) => text.setValue(this.plugin.settings.openSingleQuote).onChange(async (value) => {
        this.plugin.settings.openSingleQuote = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Guillemet simple fermant").addText(
      (text) => text.setValue(this.plugin.settings.closeSingleQuote).onChange(async (value) => {
        this.plugin.settings.closeSingleQuote = value;
        await this.plugin.saveSettings();
      })
    );
    const transformTitle = containerEl.createEl("p", {
      text: "Options"
    });
    transformTitle.style.fontWeight = "bold";
    transformTitle.style.marginTop = "1.5em";
    new import_obsidian.Setting(containerEl).setName("Tirets").setDesc(
      "-- devient tiret demi-cadratin (\u2013), \u2013- devient tiret cadratin (\u2014), \u2014- devient trois tirets (---)"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.dashesEnabled).onChange(async (value) => {
        this.plugin.settings.dashesEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Ignorer le tiret demi-cadratin").setDesc(
      "Quand activ\xE9, -- est directement converti en tiret cadratin (\u2014) plut\xF4t qu'en demi-cadratin (\u2013)"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.skipEnDash).onChange(async (value) => {
        this.plugin.settings.skipEnDash = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Points de suspension").setDesc(
      "Trois points (...) seront convertis en points de suspension (\u2026)"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.ellipsisEnabled).onChange(async (value) => {
        this.plugin.settings.ellipsisEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Guillemets").setDesc(
      "Les chevrons << et >> seront convertis en guillemets fran\xE7ais \xAB et \xBB"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.guillemetsEnabled).onChange(async (value) => {
        this.plugin.settings.guillemetsEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    const frenchRulesContainer = containerEl.createEl("div");
    frenchRulesContainer.style.marginTop = "3em";
    const frenchRulesSetting = new import_obsidian.Setting(frenchRulesContainer).setName("R\xE8gles typographiques fran\xE7aises").setDesc(
      ""
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.frenchRulesEnabled).onChange(async (value) => {
        this.plugin.settings.frenchRulesEnabled = value;
        frenchRulesDescContainer.style.display = value ? "block" : "none";
        await this.plugin.saveSettings();
      })
    );
    const nameEl = frenchRulesSetting.nameEl;
    if (nameEl) {
      nameEl.style.fontWeight = "bold";
    }
    const frenchRulesDescContainer = frenchRulesContainer.createEl("div", {
      cls: "french-rules-description"
    });
    frenchRulesDescContainer.style.display = this.plugin.settings.frenchRulesEnabled ? "block" : "none";
    frenchRulesDescContainer.style.paddingLeft = "24px";
    frenchRulesDescContainer.style.marginTop = "8px";
    const frenchRulesDesc = frenchRulesDescContainer.createEl("div", {
      cls: "setting-item-description"
    });
    frenchRulesDesc.createEl("p", {
      text: "Ces r\xE8gles incluent :"
    });
    const rulesList = frenchRulesDesc.createEl("ul");
    rulesList.style.marginLeft = "20px";
    rulesList.style.marginBottom = "15px";
    rulesList.createEl("li", {
      text: 'Conversion de (" ") en guillemets fran\xE7ais (\xAB \xBB)'
    });
    rulesList.createEl("li", {
      text: "Espace fine ins\xE9cable avant les ponctuations doubles (! ? ; \xBB)"
    });
    rulesList.createEl("li", {
      text: "Espace ins\xE9cable avant les deux-points (:)"
    });
    rulesList.createEl("li", {
      text: "Espace ins\xE9cable apr\xE8s les mots d'une lettre (a, y, \xE0...)"
    });
    rulesList.createEl("li", {
      text: "Espace ins\xE9cable dans les noms compos\xE9s (Jean Dupont)"
    });
    rulesList.createEl("li", {
      text: "Espace ins\xE9cable avant les initiales (M. Dupont)"
    });
    rulesList.createEl("li", {
      text: 'Espace ins\xE9cable avant "si\xE8cle" (XXe si\xE8cle)'
    });
    rulesList.createEl("li", {
      text: 'Conversion des ligatures "oe/OE" en "\u0153/\u0152"'
    });
    rulesList.createEl("li", {
      text: "Exposants pour les ordinaux (1er, XIIe)"
    });
    rulesList.createEl("li", {
      text: "Conversion de (...) en points de suspension (\u2026)"
    });
    const noteEl = frenchRulesDescContainer.createEl("div", {
      cls: "setting-item-description"
    });
    noteEl.createEl("p", {
      text: "Sources :"
    });
    const infoList = noteEl.createEl("ul");
    const infoItem = infoList.createEl("li");
    infoItem.createEl("a", {
      href: "https://gitlab.com/JulieBlanc/typesetting-tools/-/blob/master/regex-typo.js?ref_type=heads",
      text: "typesetting-tools (Julie Blanc)"
    });
    const infoItem2 = infoList.createEl("li");
    infoItem2.createEl("a", {
      href: "https://typomanie.fr/tag/micro-typographie/",
      text: "Le Petit manuel de composition typographique. (Muriel Paris)"
    });
  }
  /**
   * Crée les paramètres de mise en évidence
   * @param containerEl Conteneur parent
   */
  createHighlightSettings(containerEl) {
    const desEl = containerEl.createEl("p", {
      text: "Affichage des caract\xE8res invisibles"
    });
    desEl.style.fontWeight = "bold";
    desEl.style.marginTop = "3em";
    new import_obsidian.Setting(containerEl).setName("Activer l'affichage des caract\xE8res invisibles").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightEnabled).onChange(async (value) => {
        this.plugin.settings.highlightEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Bouton dans la barre d'\xE9tat").setDesc(
      "Afficher un bouton d'activation/d\xE9sactivation"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.highlightButton).onChange(async (value) => {
        this.plugin.settings.highlightButton = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Bouton dans la barre de titre").setDesc(
      "Afficher un bouton d'activation/d\xE9sactivation dans la barre de titre des onglets"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.tabTitleBarButton).onChange(async (value) => {
        this.plugin.settings.tabTitleBarButton = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/ui/decorations.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
function createDecorations(settings) {
  const nonBreakingSpaceDecoration = import_view.Decoration.mark({
    class: "nonBreakingSpace"
  });
  const thinSpaceDecoration = import_view.Decoration.mark({
    class: "thinSpace"
  });
  const emDashDecoration = import_view.Decoration.mark({
    class: "em-dash"
  });
  const regularSpaceDecoration = import_view.Decoration.mark({
    class: "regularSpace"
  });
  return import_view.ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      if (settings.highlightEnabled) {
        for (let { from, to } of view.visibleRanges) {
          let text = view.state.doc.sliceString(from, to);
          let documentText = view.state.doc.toString();
          let startPos = from;
          let inFrontmatter = false;
          let inCodeBlock = false;
          let lineStart = true;
          for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const pos = startPos + i;
            const currentPos = view.state.doc.lineAt(pos);
            const lineNumber = currentPos.number - 1;
            if (lineStart && text.substr(i, 3) === "---") {
              inFrontmatter = !inFrontmatter;
              i += 2;
              lineStart = false;
              continue;
            }
            if (lineStart && text.substr(i, 3) === "```") {
              inCodeBlock = !inCodeBlock;
              i += 2;
              lineStart = false;
              continue;
            }
            if (char === "\n") {
              lineStart = true;
            } else if (lineStart && char !== " " && char !== "	") {
              lineStart = false;
            }
            const isInSpecialBlock2 = inFrontmatter || inCodeBlock;
            if (!isInSpecialBlock2) {
              if (char === "\xA0") {
                builder.add(pos, pos + 1, nonBreakingSpaceDecoration);
              }
              if (char === "\u202F") {
                builder.add(pos, pos + 1, thinSpaceDecoration);
              }
              if (char === "\u2014") {
                builder.add(pos, pos + 1, emDashDecoration);
              }
              if (char === " ") {
                builder.add(pos, pos + 1, regularSpaceDecoration);
              }
            }
          }
        }
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
}

// src/ui/statusBar.ts
var import_obsidian2 = require("obsidian");
function createStatusBarButton(plugin, isEnabled, toggleCallback) {
  const statusBarItemEl = plugin.addStatusBarItem();
  statusBarItemEl.id = "highlight-status-bar-button";
  statusBarItemEl.addClass("mod-clickable");
  (0, import_obsidian2.setIcon)(statusBarItemEl, "pilcrow");
  statusBarItemEl.setAttribute("aria-label", "Afficher/Masquer les caract\xE8res invisibles");
  statusBarItemEl.setAttribute("data-tooltip-position", "top");
  updateStatusBarButton(statusBarItemEl, isEnabled);
  statusBarItemEl.onClickEvent(() => {
    toggleCallback();
  });
  return statusBarItemEl;
}
function createTabTitleBarButton(plugin, isEnabled, toggleCallback) {
  const buttonEl = document.createElement("button");
  buttonEl.id = "highlight-tab-title-button";
  buttonEl.className = "clickable-icon view-action";
  buttonEl.setAttribute("aria-label", "Afficher/Masquer les caract\xE8res invisibles");
  (0, import_obsidian2.setIcon)(buttonEl, "pilcrow");
  updateTabTitleBarButton(buttonEl, isEnabled);
  buttonEl.addEventListener("click", (event) => {
    event.preventDefault();
    toggleCallback();
  });
  const titleBarEl = document.querySelector(".view-header-title-container");
  if (titleBarEl) {
    const actionsEl = titleBarEl.nextElementSibling;
    if (actionsEl && actionsEl.classList.contains("view-actions")) {
      actionsEl.prepend(buttonEl);
    }
  }
  return buttonEl;
}
function updateStatusBarButton(buttonEl, isEnabled) {
  if (!buttonEl)
    return;
  if (isEnabled) {
    buttonEl.addClass("highlight-enabled");
  } else {
    buttonEl.removeClass("highlight-enabled");
  }
}
function updateTabTitleBarButton(buttonEl, isEnabled) {
  if (!buttonEl)
    return;
  if (isEnabled) {
    buttonEl.addClass("is-active");
  } else {
    buttonEl.removeClass("is-active");
  }
}
function removeTabTitleBarButton(buttonEl) {
  if (buttonEl) {
    buttonEl.remove();
  }
}

// src/core/blockAnalyzer.ts
function analyzeDocumentStructure(documentText, startLine, endLine) {
  const lines = documentText.split("\n");
  const lineTypes = new Array(endLine - startLine + 1).fill("normal");
  let inFrontmatter = false;
  let inCodeBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim() === "---") {
      inFrontmatter = !inFrontmatter;
    } else if (line.trim().startsWith("```")) {
      inCodeBlock = !inCodeBlock;
    }
    if (i >= startLine && i <= endLine) {
      const relativeIndex = i - startLine;
      if (line.trim() === "---" || line.trim().startsWith("```")) {
        lineTypes[relativeIndex] = "delimiter";
      } else if (inFrontmatter) {
        lineTypes[relativeIndex] = "frontmatter";
      } else if (inCodeBlock) {
        lineTypes[relativeIndex] = "code";
      }
    }
    if (i > endLine)
      break;
  }
  return { lineTypes };
}
function isLineInSpecialBlock(documentText, lineNumber) {
  const lines = documentText.split("\n");
  let inFrontmatter = false;
  let inCodeBlock = false;
  for (let i = 0; i <= lineNumber; i++) {
    const line = lines[i];
    if (line.trim() === "---") {
      inFrontmatter = !inFrontmatter;
    } else if (line.trim().startsWith("```")) {
      inCodeBlock = !inCodeBlock;
    }
    if (i === lineNumber) {
      return inFrontmatter || inCodeBlock;
    }
  }
  return false;
}

// src/utils/helpers.ts
function isInSpecialBlock(editor) {
  const cursor = editor.getCursor();
  const text = editor.getValue();
  return isLineInSpecialBlock(text, cursor.line);
}
function isInPreservedMarkdown(editor) {
  const cursor = editor.getCursor();
  const line = editor.getLine(cursor.line);
  const codeInlinePattern = /`[^`]*`/g;
  const codeInlineMatches = [...line.matchAll(codeInlinePattern)];
  for (const match of codeInlineMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const obsidianLinkPattern = /\[\[[^\]]*\]\]/g;
  const obsidianLinkMatches = [...line.matchAll(obsidianLinkPattern)];
  for (const match of obsidianLinkMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const mathInlinePattern = /\$[^$]*\$/g;
  const mathInlineMatches = [...line.matchAll(mathInlinePattern)];
  for (const match of mathInlineMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  if (line.includes("$$")) {
    const matches = [...line.matchAll(/\$\$/g)];
    for (const match of matches) {
      const start = match.index || 0;
      const end = start + 2;
      if (cursor.ch >= start && cursor.ch <= end) {
        return true;
      }
    }
  }
  const calloutPattern = /^>\s+\[!.*\]/;
  if (calloutPattern.test(line) && cursor.ch <= line.length) {
    return true;
  }
  const urlPattern = /(https?:\/\/|www\.)[^\s]+/g;
  const urlMatches = [...line.matchAll(urlPattern)];
  for (const match of urlMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const imagePattern = /!\[.*?\]\(.*?\)/g;
  const imageMatches = [...line.matchAll(imagePattern)];
  for (const match of imageMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const linkPattern = /\[.*?\]\(.*?\)/g;
  const linkMatches = [...line.matchAll(linkPattern)];
  for (const match of linkMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const htmlTagPattern = /<[^>]*>/g;
  const htmlMatches = [...line.matchAll(htmlTagPattern)];
  for (const match of htmlMatches) {
    const start = match.index || 0;
    const end = start + match[0].length;
    if (cursor.ch >= start && cursor.ch <= end) {
      return true;
    }
  }
  const taskPattern = /^\s*- \[[ x]\]/;
  if (taskPattern.test(line) && cursor.ch <= line.indexOf("]") + 1) {
    return true;
  }
  return false;
}
async function injectCSSFromFile(plugin, fileName) {
  try {
    const pluginDir = plugin.manifest.dir;
    const filePath = `${pluginDir}/${fileName}`;
    const cssContent = await plugin.app.vault.adapter.read(filePath);
    const styleEl = document.createElement("style");
    styleEl.textContent = cssContent;
    document.head.appendChild(styleEl);
  } catch (error) {
    console.error("\xC9chec de chargement du fichier CSS:", error);
  }
}

// src/modules/liveTypography.ts
var LiveTypographyModule = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Initialise le module avec les paramètres actuels
   * @param settings Paramètres mis à jour
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Gère les événements clavier pour appliquer les règles typographiques en temps réel
   * @param event Événement clavier
   * @param editor Éditeur Obsidian
   * @returns true si l'événement a été géré, false sinon
   */
  handleKeyEvent(event, editor) {
    if (isInSpecialBlock(editor) || isInPreservedMarkdown(editor)) {
      return false;
    }
    const cursor = editor.getCursor();
    let handled = false;
    if (event.key === "'") {
      event.preventDefault();
      const selection = editor.getSelection();
      if (selection.length > 0) {
        editor.replaceSelection(this.settings.openSingleQuote);
      } else {
        editor.replaceRange(this.settings.openSingleQuote, cursor);
        editor.setCursor({ line: cursor.line, ch: cursor.ch + this.settings.openSingleQuote.length });
      }
      handled = true;
    } else if (["!", "?", ";"].includes(event.key) && this.settings.frenchRulesEnabled) {
      event.preventDefault();
      const charBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 1 },
        cursor
      );
      if (charBefore === " ") {
        editor.replaceRange(
          "\u202F" + event.key,
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
      } else {
        editor.replaceRange(event.key, cursor);
      }
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
      handled = true;
    } else if (event.key === ":" && this.settings.frenchRulesEnabled) {
      event.preventDefault();
      const charBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 1 },
        cursor
      );
      if (charBefore === " ") {
        editor.replaceRange(
          "\xA0" + event.key,
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
      } else {
        editor.replaceRange(event.key, cursor);
      }
      editor.setCursor({ line: cursor.line, ch: cursor.ch + 1 });
      handled = true;
    } else if (event.key === '"') {
      event.preventDefault();
      const quoteSet = this.settings.openDoubleQuote + this.settings.closeDoubleQuote;
      editor.replaceRange(quoteSet, cursor);
      editor.setCursor({
        line: cursor.line,
        ch: cursor.ch + this.settings.openDoubleQuote.length
      });
      handled = true;
    } else if (event.key === "." && this.settings.ellipsisEnabled) {
      const textBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 2 },
        cursor
      );
      if (textBefore === "..") {
        event.preventDefault();
        editor.replaceRange(
          "\u2026",
          { line: cursor.line, ch: cursor.ch - 2 },
          cursor
        );
        editor.setCursor({ line: cursor.line, ch: cursor.ch - 1 });
        handled = true;
      }
    } else if (event.key === "-" && this.settings.dashesEnabled) {
      const textBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 1 },
        cursor
      );
      if (this.settings.skipEnDash) {
        if (textBefore === "-") {
          event.preventDefault();
          editor.replaceRange(
            "\u2014",
            { line: cursor.line, ch: cursor.ch - 1 },
            cursor
          );
          editor.setCursor({ line: cursor.line, ch: cursor.ch });
          handled = true;
        }
      } else {
        if (textBefore === "-") {
          event.preventDefault();
          editor.replaceRange(
            "\u2013",
            { line: cursor.line, ch: cursor.ch - 1 },
            cursor
          );
          editor.setCursor({ line: cursor.line, ch: cursor.ch });
          handled = true;
        } else if (textBefore === "\u2013") {
          event.preventDefault();
          editor.replaceRange(
            "\u2014",
            { line: cursor.line, ch: cursor.ch - 1 },
            cursor
          );
          editor.setCursor({ line: cursor.line, ch: cursor.ch });
          handled = true;
        } else if (textBefore === "\u2014") {
          event.preventDefault();
          editor.replaceRange(
            "---",
            { line: cursor.line, ch: cursor.ch - 1 },
            cursor
          );
          editor.setCursor({ line: cursor.line, ch: cursor.ch + 2 });
          handled = true;
        }
      }
    } else if (event.key === ">" && this.settings.guillemetsEnabled) {
      const textBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 1 },
        cursor
      );
      if (textBefore === ">") {
        event.preventDefault();
        editor.replaceRange(
          "\u202F\xBB",
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
        editor.setCursor({ line: cursor.line, ch: cursor.ch });
        handled = true;
      }
    } else if (event.key === "<" && this.settings.guillemetsEnabled) {
      const textBefore = editor.getRange(
        { line: cursor.line, ch: cursor.ch - 1 },
        cursor
      );
      if (textBefore === "<") {
        event.preventDefault();
        editor.replaceRange(
          "\xAB\u202F",
          { line: cursor.line, ch: cursor.ch - 1 },
          cursor
        );
        editor.setCursor({ line: cursor.line, ch: cursor.ch });
        handled = true;
      }
    }
    return handled;
  }
};

// src/core/typographyRules.ts
var CompiledTypographyRules = class {
  /**
   * Compile et met en cache les règles pour éviter la recompilation
   */
  static getCompiledRules(settings) {
    const key = this.createSettingsKey(settings);
    if (!this.compiledRules.has(key)) {
      this.compiledRules.set(key, this.compileOptimizedRules(settings));
    }
    return this.compiledRules.get(key);
  }
  static createSettingsKey(settings) {
    return JSON.stringify({
      openDoubleQuote: settings.openDoubleQuote,
      closeDoubleQuote: settings.closeDoubleQuote,
      openSingleQuote: settings.openSingleQuote,
      frenchRulesEnabled: settings.frenchRulesEnabled,
      dashesEnabled: settings.dashesEnabled,
      skipEnDash: settings.skipEnDash,
      ellipsisEnabled: settings.ellipsisEnabled,
      guillemetsEnabled: settings.guillemetsEnabled
    });
  }
  static compileOptimizedRules(settings) {
    const frenchRules = [];
    if (settings.openSingleQuote !== "'") {
      frenchRules.push({
        reg: /'/g,
        repl: settings.openSingleQuote
      });
    }
    if (settings.ellipsisEnabled) {
      frenchRules.push({
        reg: /\.{3,}/g,
        repl: "\u2026"
      });
    }
    if (settings.guillemetsEnabled) {
      frenchRules.push(
        { reg: /<</g, repl: "\xAB\u202F" },
        { reg: />>/g, repl: "\u202F\xBB" }
      );
    }
    frenchRules.push({
      reg: new RegExp(`"([A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0153\u0152])`, "g"),
      repl: settings.openDoubleQuote + "$1"
    });
    frenchRules.push({
      reg: new RegExp(`([A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0153\u0152][!?;:.,]?)\\s*"`, "g"),
      repl: "$1" + settings.closeDoubleQuote
    });
    if (settings.frenchRulesEnabled) {
      frenchRules.push(
        // Ligatures - patterns spécifiques et rapides
        { reg: /\boe\b/g, repl: "\u0153" },
        { reg: /\bOe\b/g, repl: "\u0152" },
        { reg: /\bOE\b/g, repl: "\u0152" },
        { reg: /\bae\b/g, repl: "\xE6" },
        { reg: /\bAe\b/g, repl: "\xC6" },
        { reg: /\bAE\b/g, repl: "\xC6" },
        // Ordinaux - patterns non-greedy
        { reg: /(X|I|V)(ème|eme|éme)/g, repl: "$1e" },
        // Nettoyer les espaces normaux SEULEMENT (préserver les espaces fines)
        { reg: /[ \t]+([!?;:»›")\]\.\,])/g, repl: "$1" },
        // Espaces typographiques - application directe
        { reg: /([!?;»›])/g, repl: "\u202F$1" },
        { reg: /([^\s:\/])(:)(?!\/\/)/g, repl: "$1\xA0$2" },
        // Guillemets avec cleanup atomique
        { reg: /([«‹])\s*/g, repl: "$1\u202F" },
        // Mots courts - pattern très spécifique
        { reg: /\s([aày])\s/gi, repl: " $1\xA0" },
        // Noms composés
        {
          reg: /([A-ZÀ-ÖØŒ])([A-Za-zÀ-ÖØ-öø-ÿœŒ]+)\s+([A-ZÀ-ÖØŒ])([A-Za-zÀ-ÖØ-öø-ÿœŒ]+)/g,
          repl: "$1$2\xA0$3$4"
        },
        // Abréviations - pattern précis
        {
          reg: /([A-ZÀ-ÖØŒ]\.)\s+([A-ZÀ-ÖØŒ][A-Za-zÀ-ÖØ-öø-ÿœŒ]+)/g,
          repl: "$1\xA0$2"
        },
        // Siècles - pattern non-ambigu
        { reg: /(X|I|V)(er|e)\s+siècle/g, repl: "$1$2\xA0si\xE8cle" },
        // Exposants après siècles
        { reg: /(X|I|V)(er|e)/g, repl: "$1<sup>$2</sup>" },
        // Guillemets imbriqués
        { reg: /(«\u202F[^»]*)'([^']*)'([^»]*\u202F»)/g, repl: "$1\u201C$2\u201D$3" },
        { reg: /(«\u202F[^»]*)«\u202F([^»]*)\u202F»([^»]*\u202F»)/g, repl: "$1\u201C$2\u201D$3" }
        // Espace après guillemet fermant
        // { reg: /(»)([A-Za-zÀ-ÖØ-öø-ÿœŒ0-9])/g, repl: "$1 $2" }
      );
    }
    const dashRules = [];
    if (settings.dashesEnabled) {
      if (settings.skipEnDash) {
        dashRules.push({ reg: /--/g, repl: "\u2014" });
      } else {
        dashRules.push(
          { reg: /--/g, repl: "\u2013" },
          { reg: /–-/g, repl: "\u2014" },
          { reg: /—-/g, repl: "---" }
        );
      }
    }
    return { frenchRules, dashRules };
  }
  /**
   * Nettoie le cache (utile pour les tests ou changements fréquents)
   */
  static clearCache() {
    this.compiledRules.clear();
  }
};
CompiledTypographyRules.compiledRules = /* @__PURE__ */ new Map();
function compileRules(settings) {
  return CompiledTypographyRules.getCompiledRules(settings);
}
function applyRules(text, rules) {
  if (!text || text.length === 0) {
    return text;
  }
  let result = text;
  for (const rule of rules) {
    if (rule.reg.test(result)) {
      rule.reg.lastIndex = 0;
      result = result.replace(rule.reg, rule.repl);
    }
  }
  return result;
}

// src/core/textProcessor.ts
function applyAllRules(text, rules) {
  let result = text;
  const preservedElements = [];
  const patterns = [
    /\[\[.*?\]\]/g,
    // Liens Obsidian [[lien]]
    /\[.*?\]\(.*?\)/g,
    // Liens Markdown [texte](url)
    /!\[.*?\]\(.*?\)/g,
    // Images ![alt](url)
    /`[^`]+`/g,
    // Code inline `code`
    /```[\s\S]*?```/g,
    // Blocs de code
    />\s.*$/gm,
    // Callouts (lignes commençant par "> ")
    /<[^>]*>/g,
    // Balises HTML
    /\$\$[^$]*\$\$/g,
    // Équations mathématiques $$equation$$
    /\$[^$]*\$/g,
    // Équations mathématiques inline $equation$
    /\{[^}]*\}/g,
    // Contenu entre accolades {contenu}
    /https?:\/\/[^\s]+/g,
    // URLs avec http: ou https:
    /[a-z]+:\/\/[^\s]+/g,
    // Autres protocoles (ftp:, file:, etc.)
    /[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+/g
    // Adresses email
  ];
  let tempText = result;
  let elementIndex = 0;
  for (const pattern of patterns) {
    let match;
    let searchText = tempText;
    let replacedText = tempText;
    while ((match = pattern.exec(searchText)) !== null) {
      const placeholder = `__PRESERVED_ELEMENT_${elementIndex}__`;
      preservedElements.push(match[0]);
      replacedText = replacedText.replace(match[0], placeholder);
      elementIndex++;
    }
    tempText = replacedText;
  }
  tempText = applyRules(tempText, rules.frenchRules);
  tempText = applyRules(tempText, rules.dashRules);
  result = tempText;
  for (let i = 0; i < preservedElements.length; i++) {
    const placeholder = `__PRESERVED_ELEMENT_${i}__`;
    result = result.replace(placeholder, preservedElements[i]);
  }
  return result;
}
function processTextWithBlocks(text, blocks, rules) {
  const lines = text.split("\n");
  const processedLines = [];
  let normalTextBuffer = [];
  let lastBlockType = "";
  for (let i = 0; i < lines.length; i++) {
    const currentBlockType = blocks[i];
    const line = lines[i];
    if (currentBlockType === "normal") {
      normalTextBuffer.push(line);
    } else {
      if (normalTextBuffer.length > 0) {
        const processedBuffer = applyAllRules(normalTextBuffer.join("\n"), rules);
        processedLines.push(...processedBuffer.split("\n"));
        normalTextBuffer = [];
      }
      processedLines.push(line);
    }
    lastBlockType = currentBlockType;
  }
  if (normalTextBuffer.length > 0) {
    const processedBuffer = applyAllRules(normalTextBuffer.join("\n"), rules);
    processedLines.push(...processedBuffer.split("\n"));
  }
  return processedLines.join("\n");
}
async function processLargeDocument(text, blocks, rules, callback, batchSize = 500) {
  const lines = text.split("\n");
  const processedLines = [];
  for (let i = 0; i < Math.ceil(lines.length / batchSize); i++) {
    const startIdx = i * batchSize;
    const endIdx = Math.min((i + 1) * batchSize, lines.length);
    const batchLines = lines.slice(startIdx, endIdx);
    const batchBlocks = blocks.slice(startIdx, endIdx);
    const batchText = batchLines.join("\n");
    const processedBatch = processTextWithBlocks(batchText, batchBlocks, rules);
    processedLines.push(...processedBatch.split("\n"));
    if (i < Math.ceil(lines.length / batchSize) - 1) {
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
  }
  callback(processedLines.join("\n"));
}

// src/modules/batchTypography.ts
var BatchTypographyModule = class {
  constructor(settings) {
    this.settings = settings;
  }
  /**
   * Initialise le module avec les paramètres actuels
   * @param settings Paramètres mis à jour
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Applique toutes les règles typographiques sur un texte sélectionné
   * @param editor Éditeur Obsidian
   * @returns true si des modifications ont été appliquées
   */
  applyTypographicRules(editor) {
    const selection = editor.getSelection();
    if (!selection || selection.length === 0) {
      return false;
    }
    const selectionStart = editor.getCursor("from");
    const selectionEnd = editor.getCursor("to");
    const rules = compileRules(this.settings);
    const blocks = analyzeDocumentStructure(
      editor.getValue(),
      selectionStart.line,
      selectionEnd.line
    );
    const processedText = processTextWithBlocks(selection, blocks.lineTypes, rules);
    if (processedText === selection) {
      return false;
    }
    editor.replaceSelection(processedText);
    editor.setSelection(selectionStart, selectionEnd);
    return true;
  }
  /**
   * Traite de grands documents de manière asynchrone
   * @param editor Éditeur Obsidian
   * @param callback Fonction appelée lorsque le traitement est terminé
   */
  async processLargeSelection(editor, callback) {
    const selection = editor.getSelection();
    if (!selection || selection.length === 0) {
      if (callback)
        callback();
      return;
    }
    const selectionStart = editor.getCursor("from");
    const selectionEnd = editor.getCursor("to");
    if (selection.length < 1e4) {
      this.applyTypographicRules(editor);
      if (callback)
        callback();
      return;
    }
    const rules = compileRules(this.settings);
    const blocks = analyzeDocumentStructure(
      editor.getValue(),
      selectionStart.line,
      selectionEnd.line
    );
    await processLargeDocument(
      selection,
      blocks.lineTypes,
      rules,
      (processedText) => {
        editor.replaceSelection(processedText);
        editor.setSelection(selectionStart, selectionEnd);
        if (callback)
          callback();
      }
    );
  }
};

// main.ts
var Microtypographie = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarButton = null;
    this.tabTitleBarButton = null;
  }
  async onload() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.liveModule = new LiveTypographyModule(this.settings);
    this.batchModule = new BatchTypographyModule(this.settings);
    this.addSettingTab(new MicrotypographieSettingTab(this.app, this));
    this.registerDomEvent(document, "keydown", this.handleKeyDown.bind(this));
    await injectCSSFromFile(this, "styles/styles.css");
    this.registerEditorExtension(createDecorations(this.settings));
    if (this.settings.highlightButton) {
      this.statusBarButton = createStatusBarButton(
        this,
        this.settings.highlightEnabled,
        this.toggleHighlight.bind(this)
      );
    }
    if (this.settings.tabTitleBarButton) {
      this.tabTitleBarButton = createTabTitleBarButton(
        this,
        this.settings.highlightEnabled,
        this.toggleHighlight.bind(this)
      );
    }
    this.addCommand({
      id: "apply-french-typography",
      name: "Appliquer les r\xE8gles typographiques fran\xE7aises",
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          this.batchModule.applyTypographicRules(activeView.editor);
        }
      },
      hotkeys: [{ modifiers: ["Alt"], key: "f" }]
    });
    this.addCommand({
      id: "toggle-highlight",
      name: "Afficher/Masquer les caract\xE8res invisibles",
      callback: () => {
        this.toggleHighlight();
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        if (this.settings.tabTitleBarButton) {
          if (this.tabTitleBarButton) {
            this.tabTitleBarButton.remove();
          }
          this.tabTitleBarButton = createTabTitleBarButton(
            this,
            this.settings.highlightEnabled,
            this.toggleHighlight.bind(this)
          );
        }
      })
    );
  }
  // Gérer les événements clavier (délègue au module d'aperçu direct)
  handleKeyDown(event) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView || activeView.getMode() !== "source") {
      return;
    }
    const leaf = this.app.workspace.getLeaf();
    if (!leaf)
      return;
    const activeState = leaf.getViewState().state;
    if (!activeState)
      return;
    if (activeView && activeView.getMode() === "source" && activeState["source"] === false) {
      this.liveModule.handleKeyEvent(event, activeView.editor);
    }
  }
  async loadSettings() {
    const savedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS);
    if (savedData) {
      Object.keys(this.settings).forEach((key) => {
        if (key in savedData) {
          this.settings[key] = savedData[key];
        }
      });
      if ("apostrophe" in savedData || "quotationmarks" in savedData || "emdashes" in savedData) {
        console.log("Migration des param\xE8tres de Microtypographie vers la nouvelle version");
        if (savedData.apostrophe === false) {
          this.settings.openSingleQuote = "'";
          this.settings.closeSingleQuote = "'";
        }
        if (savedData.quotationmarks === false) {
          this.settings.openDoubleQuote = '"';
          this.settings.closeDoubleQuote = '"';
        }
        await this.saveSettings();
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.liveModule.updateSettings(this.settings);
    this.batchModule.updateSettings(this.settings);
    updateStatusBarButton(this.statusBarButton, this.settings.highlightEnabled);
    updateTabTitleBarButton(this.tabTitleBarButton, this.settings.highlightEnabled);
    this.refreshDecorations();
  }
  // Activer/désactiver la mise en évidence
  toggleHighlight() {
    this.settings.highlightEnabled = !this.settings.highlightEnabled;
    this.saveSettings();
  }
  // Rafraîchir les décorations
  refreshDecorations() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.MarkdownView && leaf.view.editor) {
        const editorView = leaf.view.editor.cm;
        if (editorView) {
          editorView.dispatch({
            changes: {
              from: 0,
              to: editorView.state.doc.length,
              insert: editorView.state.doc.toString()
            }
          });
        }
      }
    });
  }
  onunload() {
    removeTabTitleBarButton(this.tabTitleBarButton);
  }
};
